/* automatically generated by rust-bindgen 0.60.1 */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__fsid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__fsid_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type size_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    fn test_field___locales() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__locales)
            )
        );
    }
    test_field___locales();
    fn test_field___ctype_b() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_b)
            )
        );
    }
    test_field___ctype_b();
    fn test_field___ctype_tolower() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_tolower)
            )
        );
    }
    test_field___ctype_tolower();
    fn test_field___ctype_toupper() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_toupper)
            )
        );
    }
    test_field___ctype_toupper();
    fn test_field___names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__locale_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__names)
            )
        );
    }
    test_field___names();
}
impl Default for __locale_struct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: size_t,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " Unsigned 8-bit integer."]
pub const gsd_type_GSD_TYPE_UINT8: gsd_type = 1;
#[doc = " Unsigned 16-bit integer."]
pub const gsd_type_GSD_TYPE_UINT16: gsd_type = 2;
#[doc = " Unsigned 32-bit integer."]
pub const gsd_type_GSD_TYPE_UINT32: gsd_type = 3;
#[doc = " Unsigned 53-bit integer."]
pub const gsd_type_GSD_TYPE_UINT64: gsd_type = 4;
#[doc = " Signed 8-bit integer."]
pub const gsd_type_GSD_TYPE_INT8: gsd_type = 5;
#[doc = " Signed 16-bit integer."]
pub const gsd_type_GSD_TYPE_INT16: gsd_type = 6;
#[doc = " Signed 32-bit integer."]
pub const gsd_type_GSD_TYPE_INT32: gsd_type = 7;
#[doc = " Signed 64-bit integer."]
pub const gsd_type_GSD_TYPE_INT64: gsd_type = 8;
#[doc = " 32-bit floating point number."]
pub const gsd_type_GSD_TYPE_FLOAT: gsd_type = 9;
#[doc = " 64-bit floating point number."]
pub const gsd_type_GSD_TYPE_DOUBLE: gsd_type = 10;
#[doc = " Identifiers for the gsd data chunk element types"]
pub type gsd_type = ::std::os::raw::c_uint;
#[doc = " Open for both reading and writing"]
pub const gsd_open_flag_GSD_OPEN_READWRITE: gsd_open_flag = 1;
#[doc = " Open only for reading"]
pub const gsd_open_flag_GSD_OPEN_READONLY: gsd_open_flag = 2;
#[doc = " Open only for writing"]
pub const gsd_open_flag_GSD_OPEN_APPEND: gsd_open_flag = 3;
#[doc = " Flag for GSD file open options"]
pub type gsd_open_flag = ::std::os::raw::c_uint;
#[doc = " Success."]
pub const gsd_error_GSD_SUCCESS: gsd_error = 0;
#[doc = " IO error. Check ``errno`` for details"]
pub const gsd_error_GSD_ERROR_IO: gsd_error = -1;
#[doc = " Invalid argument passed to function."]
pub const gsd_error_GSD_ERROR_INVALID_ARGUMENT: gsd_error = -2;
#[doc = " The file is not a GSD file."]
pub const gsd_error_GSD_ERROR_NOT_A_GSD_FILE: gsd_error = -3;
#[doc = " The GSD file version cannot be read."]
pub const gsd_error_GSD_ERROR_INVALID_GSD_FILE_VERSION: gsd_error = -4;
#[doc = " The GSD file is corrupt."]
pub const gsd_error_GSD_ERROR_FILE_CORRUPT: gsd_error = -5;
#[doc = " GSD failed to allocated memory."]
pub const gsd_error_GSD_ERROR_MEMORY_ALLOCATION_FAILED: gsd_error = -6;
#[doc = " The GSD file cannot store any additional unique data chunk names."]
pub const gsd_error_GSD_ERROR_NAMELIST_FULL: gsd_error = -7;
#[doc = " This API call requires that the GSD file opened in with the mode GSD_OPEN_APPEND or"]
#[doc = "GSD_OPEN_READWRITE."]
pub const gsd_error_GSD_ERROR_FILE_MUST_BE_WRITABLE: gsd_error = -8;
#[doc = " This API call requires that the GSD file opened the mode GSD_OPEN_READ or"]
#[doc = "GSD_OPEN_READWRITE."]
pub const gsd_error_GSD_ERROR_FILE_MUST_BE_READABLE: gsd_error = -9;
#[doc = " Error return values"]
pub type gsd_error = ::std::os::raw::c_int;
#[doc = " v1 file: Size of a GSD name in memory. v2 file: The name buffer size is a multiple of"]
#[doc = "GSD_NAME_SIZE."]
pub const GSD_NAME_SIZE: _bindgen_ty_1 = 64;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[doc = " Reserved bytes in the header structure"]
pub const GSD_RESERVED_BYTES: _bindgen_ty_2 = 80;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[doc = " GSD file header"]
#[doc = ""]
#[doc = "The in-memory and on-disk storage of the GSD file header. Stored in the first 256 bytes of"]
#[doc = "the file."]
#[doc = ""]
#[doc = "@warning All members are **read-only** to the caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gsd_header {
    #[doc = " Magic number marking that this is a GSD file."]
    pub magic: u64,
    #[doc = " Location of the chunk index in the file."]
    pub index_location: u64,
    #[doc = " Number of index entries that will fit in the space allocated."]
    pub index_allocated_entries: u64,
    #[doc = " Location of the name list in the file."]
    pub namelist_location: u64,
    #[doc = " Number of bytes in the namelist divided by GSD_NAME_SIZE."]
    pub namelist_allocated_entries: u64,
    #[doc = " Schema version: from gsd_make_version()."]
    pub schema_version: u32,
    #[doc = " GSD file format version from gsd_make_version()."]
    pub gsd_version: u32,
    #[doc = " Name of the application that generated this file."]
    pub application: [::std::os::raw::c_char; 64usize],
    #[doc = " Name of data schema."]
    pub schema: [::std::os::raw::c_char; 64usize],
    #[doc = " Reserved for future use."]
    pub reserved: [::std::os::raw::c_char; 80usize],
}
#[test]
fn bindgen_test_layout_gsd_header() {
    assert_eq!(
        ::std::mem::size_of::<gsd_header>(),
        256usize,
        concat!("Size of: ", stringify!(gsd_header))
    );
    assert_eq!(
        ::std::mem::align_of::<gsd_header>(),
        8usize,
        concat!("Alignment of ", stringify!(gsd_header))
    );
    fn test_field_magic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_header),
                "::",
                stringify!(magic)
            )
        );
    }
    test_field_magic();
    fn test_field_index_location() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).index_location) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_header),
                "::",
                stringify!(index_location)
            )
        );
    }
    test_field_index_location();
    fn test_field_index_allocated_entries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).index_allocated_entries) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_header),
                "::",
                stringify!(index_allocated_entries)
            )
        );
    }
    test_field_index_allocated_entries();
    fn test_field_namelist_location() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).namelist_location) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_header),
                "::",
                stringify!(namelist_location)
            )
        );
    }
    test_field_namelist_location();
    fn test_field_namelist_allocated_entries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).namelist_allocated_entries) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_header),
                "::",
                stringify!(namelist_allocated_entries)
            )
        );
    }
    test_field_namelist_allocated_entries();
    fn test_field_schema_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).schema_version) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_header),
                "::",
                stringify!(schema_version)
            )
        );
    }
    test_field_schema_version();
    fn test_field_gsd_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gsd_version) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_header),
                "::",
                stringify!(gsd_version)
            )
        );
    }
    test_field_gsd_version();
    fn test_field_application() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).application) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_header),
                "::",
                stringify!(application)
            )
        );
    }
    test_field_application();
    fn test_field_schema() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).schema) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_header),
                "::",
                stringify!(schema)
            )
        );
    }
    test_field_schema();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_header),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
impl Default for gsd_header {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Index entry"]
#[doc = ""]
#[doc = "An index entry for a single chunk of data."]
#[doc = ""]
#[doc = "@warning All members are **read-only** to the caller."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gsd_index_entry {
    #[doc = " Frame index of the chunk."]
    pub frame: u64,
    #[doc = " Number of rows in the chunk."]
    pub N: u64,
    #[doc = " Location of the chunk in the file."]
    pub location: i64,
    #[doc = " Number of columns in the chunk."]
    pub M: u32,
    #[doc = " Index of the chunk name in the name list."]
    pub id: u16,
    #[doc = " Data type of the chunk: one of gsd_type."]
    pub type_: u8,
    #[doc = " Flags (for internal use)."]
    pub flags: u8,
}
#[test]
fn bindgen_test_layout_gsd_index_entry() {
    assert_eq!(
        ::std::mem::size_of::<gsd_index_entry>(),
        32usize,
        concat!("Size of: ", stringify!(gsd_index_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<gsd_index_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(gsd_index_entry))
    );
    fn test_field_frame() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_index_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frame) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_index_entry),
                "::",
                stringify!(frame)
            )
        );
    }
    test_field_frame();
    fn test_field_N() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_index_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).N) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_index_entry),
                "::",
                stringify!(N)
            )
        );
    }
    test_field_N();
    fn test_field_location() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_index_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_index_entry),
                "::",
                stringify!(location)
            )
        );
    }
    test_field_location();
    fn test_field_M() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_index_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).M) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_index_entry),
                "::",
                stringify!(M)
            )
        );
    }
    test_field_M();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_index_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_index_entry),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_index_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            30usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_index_entry),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_index_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            31usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_index_entry),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
}
#[doc = " Name/id mapping"]
#[doc = ""]
#[doc = "A string name paired with an ID. Used for storing sorted name/id mappings in a hash map."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gsd_name_id_pair {
    #[doc = " Pointer to name (actual name storage is allocated in gsd_handle)"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = " Next name/id pair with the same hash"]
    pub next: *mut gsd_name_id_pair,
    #[doc = " Entry id"]
    pub id: u16,
}
#[test]
fn bindgen_test_layout_gsd_name_id_pair() {
    assert_eq!(
        ::std::mem::size_of::<gsd_name_id_pair>(),
        24usize,
        concat!("Size of: ", stringify!(gsd_name_id_pair))
    );
    assert_eq!(
        ::std::mem::align_of::<gsd_name_id_pair>(),
        8usize,
        concat!("Alignment of ", stringify!(gsd_name_id_pair))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_name_id_pair>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_name_id_pair),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_name_id_pair>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_name_id_pair),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_name_id_pair>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_name_id_pair),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
}
impl Default for gsd_name_id_pair {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Name/id hash map"]
#[doc = ""]
#[doc = "A hash map of string names to integer identifiers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gsd_name_id_map {
    #[doc = " Name/id mappings"]
    pub v: *mut gsd_name_id_pair,
    #[doc = " Number of entries in the mapping"]
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_gsd_name_id_map() {
    assert_eq!(
        ::std::mem::size_of::<gsd_name_id_map>(),
        16usize,
        concat!("Size of: ", stringify!(gsd_name_id_map))
    );
    assert_eq!(
        ::std::mem::align_of::<gsd_name_id_map>(),
        8usize,
        concat!("Alignment of ", stringify!(gsd_name_id_map))
    );
    fn test_field_v() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_name_id_map>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_name_id_map),
                "::",
                stringify!(v)
            )
        );
    }
    test_field_v();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_name_id_map>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_name_id_map),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
impl Default for gsd_name_id_map {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Array of index entries"]
#[doc = ""]
#[doc = "May point to a mapped location of index entries in the file or an in-memory buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gsd_index_buffer {
    #[doc = " Indices in the buffer"]
    pub data: *mut gsd_index_entry,
    #[doc = " Number of entries in the buffer"]
    pub size: size_t,
    #[doc = " Number of entries available in the buffer"]
    pub reserved: size_t,
    #[doc = " Pointer to mapped data (NULL if not mapped)"]
    pub mapped_data: *mut ::std::os::raw::c_void,
    #[doc = " Number of bytes mapped"]
    pub mapped_len: size_t,
}
#[test]
fn bindgen_test_layout_gsd_index_buffer() {
    assert_eq!(
        ::std::mem::size_of::<gsd_index_buffer>(),
        40usize,
        concat!("Size of: ", stringify!(gsd_index_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<gsd_index_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(gsd_index_buffer))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_index_buffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_index_buffer),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_index_buffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_index_buffer),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_index_buffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_index_buffer),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_mapped_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_index_buffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mapped_data) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_index_buffer),
                "::",
                stringify!(mapped_data)
            )
        );
    }
    test_field_mapped_data();
    fn test_field_mapped_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_index_buffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mapped_len) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_index_buffer),
                "::",
                stringify!(mapped_len)
            )
        );
    }
    test_field_mapped_len();
}
impl Default for gsd_index_buffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Byte buffer"]
#[doc = ""]
#[doc = "Used to buffer of small data chunks held for a buffered write at the end of a frame. Also"]
#[doc = "used to hold the names."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gsd_byte_buffer {
    #[doc = " Data"]
    pub data: *mut ::std::os::raw::c_char,
    #[doc = " Number of bytes in the buffer"]
    pub size: size_t,
    #[doc = " Number of bytes available in the buffer"]
    pub reserved: size_t,
}
#[test]
fn bindgen_test_layout_gsd_byte_buffer() {
    assert_eq!(
        ::std::mem::size_of::<gsd_byte_buffer>(),
        24usize,
        concat!("Size of: ", stringify!(gsd_byte_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<gsd_byte_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(gsd_byte_buffer))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_byte_buffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_byte_buffer),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_byte_buffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_byte_buffer),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_byte_buffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_byte_buffer),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
impl Default for gsd_byte_buffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Name buffer"]
#[doc = ""]
#[doc = "Holds a list of string names in order separated by NULL terminators. In v1 files, each name"]
#[doc = "is 64 bytes. In v2 files, only one NULL terminator is placed between each name."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gsd_name_buffer {
    #[doc = " Data"]
    pub data: gsd_byte_buffer,
    #[doc = " Number of names in the list"]
    pub n_names: size_t,
}
#[test]
fn bindgen_test_layout_gsd_name_buffer() {
    assert_eq!(
        ::std::mem::size_of::<gsd_name_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(gsd_name_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<gsd_name_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(gsd_name_buffer))
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_name_buffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_name_buffer),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_n_names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_name_buffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_names) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_name_buffer),
                "::",
                stringify!(n_names)
            )
        );
    }
    test_field_n_names();
}
impl Default for gsd_name_buffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " File handle"]
#[doc = ""]
#[doc = "A handle to an open GSD file."]
#[doc = ""]
#[doc = "This handle is obtained when opening a GSD file and is passed into every method that"]
#[doc = "operates on the file."]
#[doc = ""]
#[doc = "@warning All members are **read-only** to the caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gsd_handle {
    #[doc = " File descriptor"]
    pub fd: ::std::os::raw::c_int,
    #[doc = " The file header"]
    pub header: gsd_header,
    #[doc = " Mapped data chunk index"]
    pub file_index: gsd_index_buffer,
    #[doc = " Index entries to append to the current frame"]
    pub frame_index: gsd_index_buffer,
    #[doc = " Buffered index entries to append to the current frame"]
    pub buffer_index: gsd_index_buffer,
    #[doc = " Buffered write data"]
    pub write_buffer: gsd_byte_buffer,
    #[doc = " List of names stored in the file"]
    pub file_names: gsd_name_buffer,
    #[doc = " List of names added in the current frame"]
    pub frame_names: gsd_name_buffer,
    #[doc = " The index of the last frame in the file"]
    pub cur_frame: u64,
    #[doc = " Size of the file (in bytes)"]
    pub file_size: i64,
    #[doc = " Flags passed to gsd_open() when opening this handle"]
    pub open_flags: gsd_open_flag,
    #[doc = " Access the names in the namelist"]
    pub name_map: gsd_name_id_map,
}
#[test]
fn bindgen_test_layout_gsd_handle() {
    assert_eq!(
        ::std::mem::size_of::<gsd_handle>(),
        512usize,
        concat!("Size of: ", stringify!(gsd_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<gsd_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(gsd_handle))
    );
    fn test_field_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_handle>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_handle),
                "::",
                stringify!(fd)
            )
        );
    }
    test_field_fd();
    fn test_field_header() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_handle>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_handle),
                "::",
                stringify!(header)
            )
        );
    }
    test_field_header();
    fn test_field_file_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_handle>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).file_index) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_handle),
                "::",
                stringify!(file_index)
            )
        );
    }
    test_field_file_index();
    fn test_field_frame_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_handle>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frame_index) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_handle),
                "::",
                stringify!(frame_index)
            )
        );
    }
    test_field_frame_index();
    fn test_field_buffer_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_handle>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer_index) as usize - ptr as usize
            },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_handle),
                "::",
                stringify!(buffer_index)
            )
        );
    }
    test_field_buffer_index();
    fn test_field_write_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_handle>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).write_buffer) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_handle),
                "::",
                stringify!(write_buffer)
            )
        );
    }
    test_field_write_buffer();
    fn test_field_file_names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_handle>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).file_names) as usize - ptr as usize
            },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_handle),
                "::",
                stringify!(file_names)
            )
        );
    }
    test_field_file_names();
    fn test_field_frame_names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_handle>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frame_names) as usize - ptr as usize
            },
            440usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_handle),
                "::",
                stringify!(frame_names)
            )
        );
    }
    test_field_frame_names();
    fn test_field_cur_frame() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_handle>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cur_frame) as usize - ptr as usize
            },
            472usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_handle),
                "::",
                stringify!(cur_frame)
            )
        );
    }
    test_field_cur_frame();
    fn test_field_file_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_handle>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).file_size) as usize - ptr as usize
            },
            480usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_handle),
                "::",
                stringify!(file_size)
            )
        );
    }
    test_field_file_size();
    fn test_field_open_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_handle>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).open_flags) as usize - ptr as usize
            },
            488usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_handle),
                "::",
                stringify!(open_flags)
            )
        );
    }
    test_field_open_flags();
    fn test_field_name_map() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<gsd_handle>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name_map) as usize - ptr as usize
            },
            496usize,
            concat!(
                "Offset of field: ",
                stringify!(gsd_handle),
                "::",
                stringify!(name_map)
            )
        );
    }
    test_field_name_map();
}
impl Default for gsd_handle {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Specify a version"]
    #[doc = ""]
    #[doc = "@param major major version"]
    #[doc = "@param minor minor version"]
    #[doc = ""]
    #[doc = "@return a packed version number aaaa.bbbb suitable for storing in a gsd file version entry."]
    pub fn gsd_make_version(major: ::std::os::raw::c_uint, minor: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    #[doc = " Create a GSD file"]
    #[doc = ""]
    #[doc = "@param fname File name."]
    #[doc = "@param application Generating application name (truncated to 63 chars)."]
    #[doc = "@param schema Schema name for data to be written in this GSD file (truncated to 63 chars)."]
    #[doc = "@param schema_version Version of the scheme data to be written (make with"]
    #[doc = "gsd_make_version())."]
    #[doc = ""]
    #[doc = "@post Create an empty gsd file in a file of the given name. Overwrite any existing file at"]
    #[doc = "that location."]
    #[doc = ""]
    #[doc = "The generated gsd file is not opened. Call gsd_open() to open it for writing."]
    #[doc = ""]
    #[doc = "@return"]
    #[doc = "- GSD_SUCCESS (0) on success. Negative value on failure:"]
    #[doc = "- GSD_ERROR_IO: IO error (check errno)."]
    pub fn gsd_create(
        fname: *const ::std::os::raw::c_char,
        application: *const ::std::os::raw::c_char,
        schema: *const ::std::os::raw::c_char,
        schema_version: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create and open a GSD file"]
    #[doc = ""]
    #[doc = "@param handle Handle to open."]
    #[doc = "@param fname File name."]
    #[doc = "@param application Generating application name (truncated to 63 chars)."]
    #[doc = "@param schema Schema name for data to be written in this GSD file (truncated to 63 chars)."]
    #[doc = "@param schema_version Version of the scheme data to be written (make with"]
    #[doc = "gsd_make_version())."]
    #[doc = "@param flags Either GSD_OPEN_READWRITE, or GSD_OPEN_APPEND."]
    #[doc = "@param exclusive_create Set to non-zero to force exclusive creation of the file."]
    #[doc = ""]
    #[doc = "@post Create an empty gsd file with the given name. Overwrite any existing file at that"]
    #[doc = "location."]
    #[doc = ""]
    #[doc = "Open the generated gsd file in *handle*."]
    #[doc = ""]
    #[doc = "The file descriptor is closed if there when an error opening the file."]
    #[doc = ""]
    #[doc = "@return"]
    #[doc = "- GSD_SUCCESS (0) on success. Negative value on failure:"]
    #[doc = "- GSD_ERROR_IO: IO error (check errno)."]
    #[doc = "- GSD_ERROR_NOT_A_GSD_FILE: Not a GSD file."]
    #[doc = "- GSD_ERROR_INVALID_GSD_FILE_VERSION: Invalid GSD file version."]
    #[doc = "- GSD_ERROR_FILE_CORRUPT: Corrupt file."]
    #[doc = "- GSD_ERROR_MEMORY_ALLOCATION_FAILED: Unable to allocate memory."]
    pub fn gsd_create_and_open(
        handle: *mut gsd_handle,
        fname: *const ::std::os::raw::c_char,
        application: *const ::std::os::raw::c_char,
        schema: *const ::std::os::raw::c_char,
        schema_version: u32,
        flags: gsd_open_flag,
        exclusive_create: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Open a GSD file"]
    #[doc = ""]
    #[doc = "@param handle Handle to open."]
    #[doc = "@param fname File name to open."]
    #[doc = "@param flags Either GSD_OPEN_READWRITE, GSD_OPEN_READONLY, or GSD_OPEN_APPEND."]
    #[doc = ""]
    #[doc = "@pre The file name *fname* is a GSD file."]
    #[doc = ""]
    #[doc = "@post Open a GSD file and populates the handle for use by API calls."]
    #[doc = ""]
    #[doc = "The file descriptor is closed if there is an error opening the file."]
    #[doc = ""]
    #[doc = "@return"]
    #[doc = "- GSD_SUCCESS (0) on success. Negative value on failure:"]
    #[doc = "- GSD_ERROR_IO: IO error (check errno)."]
    #[doc = "- GSD_ERROR_NOT_A_GSD_FILE: Not a GSD file."]
    #[doc = "- GSD_ERROR_INVALID_GSD_FILE_VERSION: Invalid GSD file version."]
    #[doc = "- GSD_ERROR_FILE_CORRUPT: Corrupt file."]
    #[doc = "- GSD_ERROR_MEMORY_ALLOCATION_FAILED: Unable to allocate memory."]
    pub fn gsd_open(
        handle: *mut gsd_handle,
        fname: *const ::std::os::raw::c_char,
        flags: gsd_open_flag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Truncate a GSD file"]
    #[doc = ""]
    #[doc = "@param handle Open GSD file to truncate."]
    #[doc = ""]
    #[doc = "After truncating, a file will have no frames and no data chunks. The file size will be that"]
    #[doc = "of a newly created gsd file. The application, schema, and schema version metadata will be"]
    #[doc = "kept. Truncate does not close and reopen the file, so it is suitable for writing restart"]
    #[doc = "files on Lustre file systems without any metadata access."]
    #[doc = ""]
    #[doc = "@return"]
    #[doc = "- GSD_SUCCESS (0) on success. Negative value on failure:"]
    #[doc = "- GSD_ERROR_IO: IO error (check errno)."]
    #[doc = "- GSD_ERROR_NOT_A_GSD_FILE: Not a GSD file."]
    #[doc = "- GSD_ERROR_INVALID_GSD_FILE_VERSION: Invalid GSD file version."]
    #[doc = "- GSD_ERROR_FILE_CORRUPT: Corrupt file."]
    #[doc = "- GSD_ERROR_MEMORY_ALLOCATION_FAILED: Unable to allocate memory."]
    pub fn gsd_truncate(handle: *mut gsd_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close a GSD file"]
    #[doc = ""]
    #[doc = "@param handle GSD file to close."]
    #[doc = ""]
    #[doc = "@pre *handle* was opened by gsd_open()."]
    #[doc = "@pre gsd_end_frame() has been called since the last call to gsd_write_chunk()."]
    #[doc = ""]
    #[doc = "@post The file is closed."]
    #[doc = "@post *handle* is freed and can no longer be used."]
    #[doc = ""]
    #[doc = "@warning Ensure that all gsd_write_chunk() calls are committed with gsd_end_frame() before"]
    #[doc = "closing the file."]
    #[doc = ""]
    #[doc = "@return"]
    #[doc = "- GSD_SUCCESS (0) on success. Negative value on failure:"]
    #[doc = "- GSD_ERROR_IO: IO error (check errno)."]
    #[doc = "- GSD_ERROR_INVALID_ARGUMENT: *handle* is NULL."]
    pub fn gsd_close(handle: *mut gsd_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Commit the current frame and increment the frame counter."]
    #[doc = ""]
    #[doc = "@param handle Handle to an open GSD file"]
    #[doc = ""]
    #[doc = "@pre *handle* was opened by gsd_open()."]
    #[doc = "@pre gsd_write_chunk() has been called at least once since the last call to gsd_end_frame()."]
    #[doc = ""]
    #[doc = "@post The current frame counter is increased by 1 and cached indexes are written to disk."]
    #[doc = ""]
    #[doc = "@return"]
    #[doc = "- GSD_SUCCESS (0) on success. Negative value on failure:"]
    #[doc = "- GSD_ERROR_IO: IO error (check errno)."]
    #[doc = "- GSD_ERROR_INVALID_ARGUMENT: *handle* is NULL."]
    #[doc = "- GSD_ERROR_FILE_MUST_BE_WRITABLE: The file was opened read-only."]
    #[doc = "- GSD_ERROR_MEMORY_ALLOCATION_FAILED: Unable to allocate memory."]
    pub fn gsd_end_frame(handle: *mut gsd_handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a data chunk to the current frame"]
    #[doc = ""]
    #[doc = "@param handle Handle to an open GSD file."]
    #[doc = "@param name Name of the data chunk."]
    #[doc = "@param type type ID that identifies the type of data in *data*."]
    #[doc = "@param N Number of rows in the data."]
    #[doc = "@param M Number of columns in the data."]
    #[doc = "@param flags set to 0, non-zero values reserved for future use."]
    #[doc = "@param data Data buffer."]
    #[doc = ""]
    #[doc = "@pre *handle* was opened by gsd_open()."]
    #[doc = "@pre *name* is a unique name for data chunks in the given frame."]
    #[doc = "@pre data is allocated and contains at least `N * M * gsd_sizeof_type(type)` bytes."]
    #[doc = ""]
    #[doc = "@post The given data chunk is written to the end of the file and its location is updated in"]
    #[doc = "the in-memory index."]
    #[doc = ""]
    #[doc = "@note If the GSD file is version 1.0, the chunk name is truncated to 63 bytes. GSD version"]
    #[doc = "2.0 files support arbitrarily long names."]
    #[doc = ""]
    #[doc = "@note *N* == 0 is allowed. When *N* is 0, *data* may be NULL."]
    #[doc = ""]
    #[doc = "@return"]
    #[doc = "- GSD_SUCCESS (0) on success. Negative value on failure:"]
    #[doc = "- GSD_ERROR_IO: IO error (check errno)."]
    #[doc = "- GSD_ERROR_INVALID_ARGUMENT: *handle* is NULL, *N* == 0, *M* == 0, *type* is invalid, or"]
    #[doc = "flags* != 0."]
    #[doc = "- GSD_ERROR_FILE_MUST_BE_WRITABLE: The file was opened read-only."]
    #[doc = "- GSD_ERROR_NAMELIST_FULL: The file cannot store any additional unique chunk names."]
    #[doc = "- GSD_ERROR_MEMORY_ALLOCATION_FAILED: failed to allocate memory."]
    pub fn gsd_write_chunk(
        handle: *mut gsd_handle,
        name: *const ::std::os::raw::c_char,
        type_: gsd_type,
        N: u64,
        M: u32,
        flags: u8,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Find a chunk in the GSD file"]
    #[doc = ""]
    #[doc = "@param handle Handle to an open GSD file"]
    #[doc = "@param frame Frame to look for chunk"]
    #[doc = "@param name Name of the chunk to find"]
    #[doc = ""]
    #[doc = "@pre *handle* was opened by gsd_open() in read or readwrite mode."]
    #[doc = ""]
    #[doc = "The found entry contains size and type metadata and can be passed to gsd_read_chunk() to"]
    #[doc = "read the data."]
    #[doc = ""]
    #[doc = "@return A pointer to the found chunk, or NULL if not found."]
    pub fn gsd_find_chunk(
        handle: *const gsd_handle,
        frame: u64,
        name: *const ::std::os::raw::c_char,
    ) -> *const gsd_index_entry;
}
extern "C" {
    #[doc = " Read a chunk from the GSD file"]
    #[doc = ""]
    #[doc = "@param handle Handle to an open GSD file."]
    #[doc = "@param data Data buffer to read into."]
    #[doc = "@param chunk Chunk to read."]
    #[doc = ""]
    #[doc = "@pre *handle* was opened in read or readwrite mode."]
    #[doc = "@pre *chunk* was found by gsd_find_chunk()."]
    #[doc = "@pre *data* points to an allocated buffer with at least `N * M * gsd_sizeof_type(type)`"]
    #[doc = "bytes."]
    #[doc = ""]
    #[doc = "@return"]
    #[doc = "- GSD_SUCCESS (0) on success. Negative value on failure:"]
    #[doc = "- GSD_ERROR_IO: IO error (check errno)."]
    #[doc = "- GSD_ERROR_INVALID_ARGUMENT: *handle* is NULL, *data* is NULL, or *chunk* is NULL."]
    #[doc = "- GSD_ERROR_FILE_MUST_BE_READABLE: The file was opened in append mode."]
    #[doc = "- GSD_ERROR_FILE_CORRUPT: The GSD file is corrupt."]
    pub fn gsd_read_chunk(
        handle: *const gsd_handle,
        data: *mut ::std::os::raw::c_void,
        chunk: *const gsd_index_entry,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of frames in the GSD file"]
    #[doc = ""]
    #[doc = "@param handle Handle to an open GSD file"]
    #[doc = ""]
    #[doc = "@pre *handle* was opened by gsd_open()."]
    #[doc = ""]
    #[doc = "@return The number of frames in the file, or 0 on error."]
    pub fn gsd_get_nframes(handle: *const gsd_handle) -> u64;
}
extern "C" {
    #[doc = " Query size of a GSD type ID."]
    #[doc = ""]
    #[doc = "@param type Type ID to query."]
    #[doc = ""]
    #[doc = "@return Size of the given type in bytes, or 0 for an unknown type ID."]
    pub fn gsd_sizeof_type(type_: gsd_type) -> size_t;
}
extern "C" {
    #[doc = " Search for chunk names in a gsd file."]
    #[doc = ""]
    #[doc = "@param handle Handle to an open GSD file."]
    #[doc = "@param match String to match."]
    #[doc = "@param prev Search starting point."]
    #[doc = ""]
    #[doc = "@pre *handle* was opened by gsd_open()"]
    #[doc = "@pre *prev* was returned by a previous call to gsd_find_matching_chunk_name()"]
    #[doc = ""]
    #[doc = "To find the first matching chunk name, pass NULL for prev. Pass in the previous found string"]
    #[doc = "to find the next after that, and so on. Chunk names match if they begin with the string in"]
    #[doc = "match*. Chunk names returned by this function may be present in at least one frame."]
    #[doc = ""]
    #[doc = "@return Pointer to a string, NULL if no more matching chunks are found found, or NULL if"]
    #[doc = "prev* is invalid"]
    pub fn gsd_find_matching_chunk_name(
        handle: *const gsd_handle,
        match_: *const ::std::os::raw::c_char,
        prev: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Upgrade a GSD file to the latest specification."]
    #[doc = ""]
    #[doc = "@param handle Handle to an open GSD file"]
    #[doc = ""]
    #[doc = "@pre *handle* was opened by gsd_open() with a writable mode."]
    #[doc = "@pre There are no pending data to write to the file in gsd_end_frame()"]
    #[doc = ""]
    #[doc = "@return"]
    #[doc = "- GSD_SUCCESS (0) on success. Negative value on failure:"]
    #[doc = "- GSD_ERROR_IO: IO error (check errno)."]
    #[doc = "- GSD_ERROR_INVALID_ARGUMENT: *handle* is NULL"]
    #[doc = "- GSD_ERROR_FILE_MUST_BE_WRITABLE: The file was opened in read-only mode."]
    pub fn gsd_upgrade(handle: *mut gsd_handle) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
